### 自我介绍：

Hello，我叫xxx，我是18年毕业的，从事前端行业有2年多，主要使用的技术栈是react,hooks,redux进行开发，平日也有关注vue和小程序方面的技术栈。我第一年实习的时候在公司里主要做的是小程序的项目，近些年主要是负责公司的sass管理平台的开发业务。在项目中我主要负责的是订单，商品，客服等等一些较为核心的模块，平日里也参与团队的公共组件的编写和维护，为团队的开发带来便利，加速了开发进度同时也为业务带来稳定性。谢谢，以上就是我的自我介绍。

### 你有参加项目的选型吗？

有参与sass管理后台的选型，主要考虑几个方面吧，一个是使用惯性问题，公司团队主要使用的是react全家桶写代码比较多，那为了减少学习成本所以依旧沿用react和redux;数据管理库方面我们主要采用的是redux，(我们也比对了一下mobx，认为mobx提供的约定和模板较少，开发编写过程比较自由，容易造成团队代码风格不一致的问题，所以出于维护性的考虑我们更偏向于使用redux。)在开发中我们面临比较大的问题是组件的问题，所以一直在探索和改造我们组件的创造模式，一开始我们的组件封装都是比较零散和更偏向于业务去封装组件的，但后期项目越来越大和代码量越来也多的时候，组件的问题就凸显出来了，之后我们将一些组件的粒度拆分得更细来解决耦合问题，到后期我们采用npm包管理的形式去试着将组件复用性提高一个层次，以便于维护saas管理开发过程中组件应用。

### 接口类型的定义，数据结构是如何跟后端沟通与规划的？

平时开发过程中使用get和post请求是最多的，通常一些列表类型的接口用get请求，一些表单的操作用post请求。数据结构方面的规划我们会开接口评审会议的。通常我们的开发安排都是先产品出原型，然后前端先进行静态页面编写，之后在联调开始前，我们会开前后端接口评审会议，那么前后端心里都会有个底吧，大概知道自己需要什么样的数据结构和接口规划，接口评审会过程中我们都会结合渲染和数据处理与后端沟通数据结构和请求方式的安排的。那么可以减少了很多不必要的误会和调整。

### 组件的封装思想是什么?

组件的封装应保持低耦合高复用的方案确保可维护性，并且在维护迭代时应遵循开闭原则，保持组件的稳定性。子组件应保持对父组件的细节了解程度处于了解甚少或一无所知，由父组件通过props传递参数去控制子组件的操作和展示，而不是将一些业务个性化的逻辑放置到子组件中，平时在封装的过程中要写注释和对组件做容错处理，开发过程中接入propTypes和eslint，保持代码的严谨和参数的正确。

### 小程序登录过程能说一说吗？

小程序的登录设计:前端使用wx.login api的调用，换取临时登录凭证code值，然后把这个code值回传给后台，后台获取到code值后，会调用微信第三方接口jscode2session换取session_key和openID。之后对session_key和openid进行加密处理随机生成一个新的sesion（3rd_session）给前端使用，前端调用接口带上这个3rd_session给后端，后端会进行解析比较的，这样做的好处是避免了一些安全性的风险。

### 小程序的登录优化你有什么看法？

场景一：在授权登录的时候，如果用户第一次拒绝授权，短时间内无法唤起授权窗口弹出，这个时候我们需要提示打开授权面板，让用户再次操作。

场景二：校验session_key是否过期，微信提供了wx.checksession的方法给我们，但如果我们在每次请求接口前都对session_key进行校验的话，是比较耗时的，大约需要200毫秒才能进行校验完成，这样的话体验比较差，后期我们没有在请求前校验，而是自己写了一套校验方式，每次请求前先进行前端的校验，校验stroge里面是否有存储过sesion_key，如果没有则进行登录流程，如果有，则到调用接口时，若接口返回登录错误验证码时，再进行到重新登录流程，这样做的话可以避开了checksession的校验耗时问题

### react的原理：

react 是一个视图层框架，他的数据模式是单向数据流的，只能通过修改props或者setState来进行数据的变更。当数据发生改变的时候，会产生新旧dom，新旧dom会在react的虚拟dom上进行diff算法比较，得出差异值后，会把差异部分更新到新的dom上，然后重新构建新的dom树从而驱动视图层的改变。



### diff算法原理：

diff算法主要的作用是用来计算新旧dom的差异，是react中开销最大的。

diff算法遵循三大策略：

- Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。（同层级比较，当发现节点不存在时，则会删除该节点以及旗下的子节点，不进行下一步的比较，减少复杂度）

- 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构

- 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。



### redux的原理：

redux遵循三大原则：

- 单一数据源 （目的是为了便于维护和调试）
- state是只读的，唯一驱动state发送改变的是action
- 使用纯函数reducer来执行修改，因为纯函数没有副作用，当状态发生改变时，需要返回一个新的state，redux是对新旧state进行浅比较，是比较对象的内存地址的，如果直接修改state那么比较的是同一个内存地址，那么redux则不会进行响应。

### stateState是异步的吗？

setState是异步的，因为他是通过一个队列机制实现state更新，避免频繁重复更新state，当执行setState时，会将需要更新的state合并，放入队列中，而不是立即执行this.state来修改的。

### Refs是什么？

refs是能访问DOM元素或组件实例的一个函数。

### hooks 和class的区别？

hooks闭包问题补充：https://segmentfault.com/a/1190000020805789?utm_source=tag-newest

hooks更加符合react的面向对象的组件式开发的思想，相对复杂的class的声明的周期，hooks的钩子函数更容易理解.

Hook可以降低组件之间复用状态逻辑难的问题，并且将业务拆分成多个组件，更便于维护。一句话说完，用hooks好爽啊！

###  React.memo和useMemo和useCallback的区别和使用方式

- react.memo提供给函数组件使用的，class组件使用是pureComponent 。react.memo可以解决重复渲染的问题，优化react的render渲染次数的问题。

- useMemo对比react.memo性能优化的粒度更细，可以定义依赖，实现细节的pure功能,例如定义依赖决定函数体内的一些逻辑计算或者是一些参数作为依赖，决定视图的局部改变。

- useCallback的理念跟useMemo一样，useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数

  

### 你封装过的组件让你印象比较深刻的？

- <font color=red>模糊搜索</font>

  使用场景是用户输入关键词，接口联想名词，用户频繁输入而造成接口高并发，给服务器造成压力，并且频繁渲染容易造成页面的卡顿，用户体验不友好，因而接入了防抖函数，如果用户n秒内重复触发事件，则重新计时且函数不被执行，直到用户不再触发事件时才执行一次事件，降低接口的高频调用同时也优化了体验。

  ##### 防抖函数和节流函数的区别和应用场景？

  防抖函数的含义是：n秒内只执行最后一次的事件，使用场景有：搜索，表单提交，防重处理

  节流函数的含义是：在设定的时间内每隔n秒会固定触发一次任务，并且是规律的。使用的场景有：监听页面滚动事件，例如向上吸顶的操作，使用节流可以减少监听带来的开销

- <font color=red>canvas 截取视频首帧</font>

  getElementById查找出video节点实例，video节点作为useEffect依赖，确保video实例加载完成后，创建canvas节点，在video的onloadeddata钩子内使用canvas进行绘画，之后使用toDataURL方法将canvas对象转换为base64位编码则或获得视频的首帧图。

  必须要注意canvas的绘画必须在onloadeddata钩子内进行，确保在当前帧的数据加载完成后才能生成canvas,否则截取出的图片是黑屏。

  ##### canvas跨域问题了解过吗？怎么处理？

  canvas画出来的图片跨域的原因是因为图片不同源，浏览器拦截报跨域了，可以考虑给img元素添加crossOrigin = ``'Anonymous'属性。或者可以让后端把图片设为同源

- <font color=red>虚拟列表</font>

  用数组保存所有列表元素的位置，只渲染可视区内的列表元素，当可视区滚动时，根据滚动的offset大小以及所有列表元素的位置，计算在可视区应该渲染哪些元素。

### 虚拟列表你是怎样控制滚动条的同步的?



## 从浏览器输入URL到页面加载发生了什么？

浏览器获取到url后会进行dns查询，先从本地开始查找若没有查找到则向dns服务器中查找，知道找到根节点为止。随后会建立TCP链接，进行三次握手确认信息，确认双方具备数据通讯能力。随后客户端主动向服务端发起http请求，服务器接收到请求后进行资源文件处理并调用数据库信息，随后将结果响应给客户端。http请求完毕后TCP链接关闭。浏览器获取到资源后先是进行html解析生成Dom树，随后将css解析生成css规则树，在解析过程中如遇执行js脚本出现阻塞后面的渲染的情况的，这是因为js有权利改变dom结构，避免冲突从上而下执行。当dom和css规则树结合生成render树，会根据render树布局，计算css样式后之后节点和样式规格大小等几何信息会挂载到页面上。

### 盒子居中的方法有哪些？

1.（有设定父盒子）使用margin 50% 配合transform -50达到居中目的

2.（有设定父盒子）使用定位,设定top,left50%，然后使用margin减去子盒子自身一半的宽高

3.父盒子设定 display:flex;  justify-content: center;  align-items: center;

4.子盒子设为行内元素块元素，父盒子设定line-height和text-align居中

### 去重的方法能列举一下吗？

##### 以下方式只适合数组里不含对象的去重

1.使用es6的set方法进行去重

2.使用indexOf或者lastIndexOf判断值的出现情况，如果值第一次出现则存入新的数组中

补充：

- indexOf 和 lastIndexOf 都是索引文件

- 　　indexOf 是查某个指定的字符串在字符串首次出现的位置（索引值）（从左往右）

- ​    lastIndexOf 是查某个指定的字符串在字符串最后一次出现的位置（索引值）（从右往左）

  - indexOf 和 lastIndexOf 都是索引文件
  - 　　indexOf 是查某个指定的字符串在字符串首次出现的位置（索引值）（从左往右）
  - ​    lastIndexOf 是查某个指定的字符串在字符串最后一次出现的位置（索引值）（从右往左）

  ```javascript
  var a = "abccccdef"
  console.log(a.indexOf('c')) //2
  console.log(a.lastIndexOf('c')) // 5
  ```

3.使用includes方法进行筛选.

4.使用对象键值对比较进行去重,如果没有出现过的键则存入数组中

```javascript
function duplicate3(arr) {
  let  res=[],obj={};
  arr.forEach((item)=>{
    if(!obj[item]){
      obj[item]=1;
      res.push(item)
    }
  });
  return res
}
```



##### 数组对象去重

1.使用reduce，根据对象中某个单一的属性进行比对

``` javascript
let obj = {};

let peon = person.reduce((cur,next) => {
    obj[next.id] ? "" : obj[next.id] = true && cur.push(next);
    return cur;
},[]) //设置cur默认类型为数组，并且初始值为空的数组
console.log(peon);
```

### websocket有接触过吗？

没有实战经验，对websocket有大概的一个了解。状态码是101

websocket协议与http协议都应用层协议，而TCP则属于传输层协议，并且ws 与http都是基于TCP实现的上层协议。

- websocket:客户端与服务端建立一个长链接全双工的通信信道，不仅使<font color=blue>客户端可以主动像服务器发送消息，也可以让服务器主动向客户端发送消息</font>，由于是长链接通道，所以每次消息的发送并不会反复创建，销毁链接。
- http只能由客户端发起请求，如遇客户端需要不停更新信息的话，前端只能使用长轮询的方式进行询问，了解服务器有没有新的信息。轮询效率低，并且浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）

### webocket频繁推送消息给前端渲染，前端要怎么做这个性能优化呢？

假设一次推送100条，并且推送很频繁，要怎样去优化呢？

每次推送新的数据的时候，替换前面的100条数据，并且在遍历的时候用索引去做key值，而不是id唯一致，这样做的好处是为了减少diff对比消耗。



### vue实现的音乐播放器

实现流程：

1.接口获取lrc格式文件,使用正则格式化，将时间与内容筛选出来一个新的数组来。新的数组长度减去容器的高度得出offset偏移值。然后用当前播放的长度加上偏移值之后再减去当前播放长度，先加后减的方法是为了解决滑动时的卡顿。

### vue是怎样传值的？

1.父组件传值给子组件，子组件通过props进行接收

2.子组件回传参数给父组件,可以通过emit事件

3.兄弟组件间的传值，使用vuex

### vue响应式双向数据绑定原理。

vue.js采用数据劫持结合发布-订阅模式，通过Object.defineProperty()来劫持data中的各个属性的setter,getter。每个组件实例对应一个watcher（订阅者）的实例，在数据变动的时候，setter的触发会通知watcher，从而使他关联的组件重新渲染

### MVVM 和MVC你是怎么理解的？

> MVC是一种软件架构模式，也有人叫做设计模式,将程序划分为三大部分，实现了职责分离，需要操作dom，需要自己实现controller的代码。

- M: Model 数据模型（专门用来操作数据，数据的CRUD）
- V：View 视图（对于前端来说，就是页面）
- C：Controller 控制器（是视图和数据模型沟通的桥梁，用于处理业务逻辑）

> MVVM，一种更好的UI模式解决方案

- M：model数据模型(ajax获取到的数据)
- V：view视图（页面）
- VM：ViewModel 视图模型

### Vue框架是什么模式？React的框架模式又是什么呢？

- Vue是mvvm模式，因为vue有独特的响应式特性，view和model直接没有直接的关联，而是通过viewModel双向数据绑定将view和model层连接起来，因此我们无需再去关心dom操作的问题。（vue的响应式设计就是mvvm里面的vm层，专门处理逻辑的地方）

  

- React不算是MVC模式，他只算是一个视图层的框架，react是一个函数式设计思路的库，追求的是无状态无副作用的函数式编程，所以里面缺少了处理数据和行为交互c层



### vue和react的区别是？

1.监听数组变化的实现原理不同

	- vue通过 getter/setter以及一些函数的劫持，能精确知道数据变化
 - react 通过diff算法计算组件差异，不必要或无变化的dom不作重新渲染
   

2.数据流的不同

	- vue的数据支持双向数据绑定
	- react不支持双向绑定，更多的是提倡单项数据流

3.渲染过程不同

	- vue在渲染过程中，跟踪每一个组件依赖关系，不需要重新渲染整个组件树
	- react是计算新旧dom之间的差异并反映到真实的dom上，从而更新我们的应用

4.框架的本质不同

 - vue本质是mvvm框架，双向数据绑定是他的亮点
 - react是视图层框架，由数据驱动视图的变化

### vuex和Redux的区别是？

其实大部分概念都差不多，只不过VUEX简化了一些流程。
store、state基本一样，只是action与mutation有些差别。
redux中数据是从action-->reducer-->更新state；
VUEX则是action（特定情况可以省略）-->mutation-->更新state。
个人认为redux是更规范的写法，VUEX是更容易上手的写法。

小补充：
	Mutation：必须同步执行。

​	Action：可以异步，但不能直接操作State。

### http与https的区别？

http是超文本传输协议，信息是明文传输，,用户数据容易被窃听，甚至可能会遭受网络劫持的情况

https 则是具有安全性的ssl加密传输协议安全性更高，防止流量被劫持，但协议握手阶段比较费时，连接不如http高效，加密通信与纯文本通信相比,消耗更多的CPU和内存资源

他们两者的相同点是：http和https都是无状态协议，因为https的s涉及的是传输而不是协议。

### 解构赋值的原理：
解构是`ES6`提供的语法糖，从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面

