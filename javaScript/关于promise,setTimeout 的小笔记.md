#### setTimoutout的时间设定为 0 会发生什么事？

下面代码是不是觉得很奇怪，为什么我的 setTimeout的时间设为 0 了，但他里面的 console 执行反而是最晚的呢？

```javascript
settsetTimeout(()=>{
    console.log(1)
},)

console.log(2)
console.log(3)

//结果打印为 231

原因：因为 js 是单线程的，单线程就意味着所有的任务都需要排队执行，前一个任务结束了，才会执行后一个任务，如果前任务耗时很长，后一个任务就不得不一直等待着。而浏览器的内核是多线程的，一个浏览器至少实现三个常驻线程：js 引擎线程，GUI 渲染线程，浏览器事件触发线程。

1.js 引擎浏览器基于事件驱动单线程执行，js 引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论何时都只有一个 js 线程在运行 js 代码。

2.GUI渲染线程负责渲染浏览器界面，当界面重绘或回流时，该线程就会执行了，但注意 JS 线程和 GUI渲染线程是互斥的，当 JS 引擎执行时，GUI 线程就会被挂起，GUI 更新会被保存在一个队列中等 js引擎空闲时立即执行。

3.事件触发线程，当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 js 引擎处理。这些事件可能来自 js 引擎当前执行的代码块，如 setTimeout，也可能来自浏览器内核的其他线程例如 click 事件，ajax 异步请求等，但由于 js 的单线程关系所有这事件都必须排队等 js 引擎处理完(当线程中没有执行任何同步代码的前提下才会执行异步)。那么当 js 引擎遇到定时器时，会将setTimeout中的 fn 这个函数放到任务队列中，当JS引擎空闲时并达到定时器的指定延迟时间时，才会将 fn 放到 js 引擎中执行。

一句话总结：js 会先执行同步代码，空闲且到达定时器设定的时间后，fn 才被放到执行的任务队列中。
```



#### 当 promise和setTimeout结合时，会发生什么事呢？

```javascript
var first = ()=>{
console.log(111)
    return new Promise((resolve,reject)=>{
        console.log(222)
        setTimeout(()=>{
            console.log(3333)
            resolve(4444)
        },0)
        resolve(5555)
    })
}

first().then(res=>{
    console.log(res)
})

//111，222，5555，3333

1.因为first被调用了，所以先是进first函数内部，遇见 111。
2.此时执行 promise，遇见 222。
3.因为定时器在 promise里面，promise内部是同步执行的，所以当碰到定时器时，定时器会等同步执行完后才会执行定时器内部的代码。此刻他往下走了，碰到resolve。至此 promise 返回了状态结果。
4.promise 的内部同步代码执行完毕，那么回过头去执行定时器。所以打印 3333
为什么没有打印 444 呢，是因为 promise一旦状态改变，则不会改变其状态，也就是说已经 resolve 或者 reject 完， 其余的状态值都是无效的。
```

