##### 前言：c++和 java，存在类（class）这个概念，所谓的‘类’就是对象的模板，对象就是“类”的实例。但是，在JavaScript语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。

https://segmentfault.com/a/1190000021232132

https://juejin.cn/post/6844904093828251662#heading-12

https://andyoung.blog.csdn.net/article/details/81008993

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain

##### 什么是原型对象？

```javascript
//因为‘面向对象编程’的第一步就是要生成对象，而 js 中面向对象编程是基于构造函数和原型链的。所以一个对象之所以能成为一个可继承可复用的对象就是通过构造函数生成的。

//我的解读：
  ▪ 在创建a函数，浏览器会在内存中创建一个对象b，函数默认会有一个 prototype 属性，指向内存中创建的对象（即 a 函数中的portotype 的属性的值来源于对象 b）这个对象 b 就是 函数 a 的原型对象，简称函数对象。
  ▪ 原型对象默认会有一个属性 constructor 指向了函数 a
  ▪ 原型对象默认只有属性constructor，其他都是从 Object继承而来，这就印证了 js 中说的，万物皆对象，对象乃 js 之母的说法了。
  ▪ object.prototype 属性表示 object 的原型对象,Function.prototype 就是所有函数的原型，Function.prototype上面承载了用于继承给所有函数的那些属性，例如 call,bind，apply 等

```

### constructor 

```javascript
▪ prototype 对象有一个constructor属性，默认constructor始终指向创建当前对象的构造函数。
▪ 这个属性其实就是将原型对象指向关联的构造函数，constructor存在于构造函数的 prototype 上。举个🌰
function Person() {
}
Person.prototype.constructor === Person // true

function Person() {
}
var person1 = new Person()
person1.constructor === Person  // true

🌺提问：person1.constructor === Person 的打印是不是说 proson1上也有constructor属性？
🌺回答：其实没有的，他是通过原型链在原型 Person.prototype 上找到的。

▪ constructor属性不影响任何JavaScript的内部属性。constructor其实没有什么用处，只是JavaScript语言设计的历史遗留物。由于constructor属性是可以变更的，所以未必真的指向对象的构造函数，只是一个提示。不过，从编程习惯上，我们应该尽量让对象的constructor指向其构造函数，以维持这个惯例。

练习：https://blog.csdn.net/zzh1251994430/article/details/108966817
```



##### super

```
super 关键字用户访问和调用一个对象的父对象上的函数。在构造函数中使用时，super 关键字将单独出现，并且必须在使用 this 关键字之前使用。
```



##### prototype对象属性指向原型对象上，那prototype和原型对象之间的关系是什么呢？

```javascript
//解答
1.先理解一下prototype是从哪里来的？通过打印，发现只要在创建函数的时候，其自身都会有一个prototype的属性，这个属性是一个指针来的，prototype属性来源于函数的内置对象，其中默认会含有constructor属性，这个属性是指向回函数本身的一个指针。但请记住只有函数才有,并且通过bind()绑定的也没有

2.具体参考上面的”什么是原型对象“里面有解答
3.所以prototype属性默认是指向函数的内置对象(function.prototype & Object.prototype)，若该函数被实例化，那么实例对象的原型对象指向被 new 的函数的原型对象上，所以看下面的🌰：
function foo(){}
console.log(foo.prototype) //{constructor: ƒ}
var f1 = new foo()
console.log(f1.__proto__) //{constructor: ƒ}
console.log(f1.__proto__ === foo.prototype) //true
由此得出：prototype的作用就是可以由特定类型的所有实例共享的属性和方法，也就是让该函数所实例化的对象们都可以找到公用的属性和方法
```



####  `__proto__` 的理解：

```
__proto__属性是对象独有的，__proto__属性都是由一个对象他们的原型对象（父对象）。
__proto__作用是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去该对象的__proto__属性所指向的那个对象（父对象）里找，若依旧没找到则一直往上找知道原型链的顶端 null,此时若还没找到则返回 undefined。以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。
```

#### 原型链

```
js 对象有一个指向一个原型对象的链，当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索。直到找到一个名字匹配的属性或者到达原型链的末位。
```

原型的继承方式



### 总结：

- 函数都会有prototype属性，prototype为一个对象，对象里面默认有一个constructor属性值指向这个函数本身。

  