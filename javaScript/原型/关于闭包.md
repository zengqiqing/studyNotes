关于闭包：

想知道闭包还存不存在，那就调用的时候，就用console.dir去打印一下，查看`*[[Scopes]]*`，查阅有没有Closure 字段，这个就是存放闭包的字段了

#### 什么是闭包？
**1.实现私有的方法和属性，禁止外部访问。**

**2.保持变量常驻内存，不被回收。**

```
解答：
传统的函数是没有状态的，他的局部变量都是保存在函数调用栈上，随着函数调用结束，退出，这些栈上变量也就被清空了（也就是说普通函数里面的变量只要普通函数被调用过了，他就是垃圾了，会被回收了，所以说他们是没有记忆的。）而闭包因一直被全局环境下的变量引用着，所以一直没有被回收一直存储在内存中

```

#### 如何创建闭包,闭包的标志是什么？
```javascript
//闭包的标志
1.函数嵌套
2.内部函数必须要被 return 出来
3.内部函数要与外部函数（只与外部函数有关联，跟全局的变量之间有关联都不会形成闭包的）作用域的变量有引用关系时，这时闭包才形成。这也引出了闭包函数虽然比销毁，但其变量对象依旧被绑定在外部函数上，保存在内存中的情况
4.闭包被全局环境下的变量引用才算是闭包
//标准的创建闭包的格式（函数嵌套函数）
function a (){
	var i = 0;
	function b(){
		console.log(++i);
	}
	return b;
}

var c = a()
console.dir(c)
//由于b函数的执行需要依赖a函数的变量，所以a,b函数不被回收，从而形成了闭包
//全局变量 c 引用着 a 函数，a 函数有把内部的 b 函数return 出来那么 b 函数才算是闭包，才会存在内存当中
闭包的作用是什么？
闭包的作用是在父函数执行完并返回后，闭包使得js的垃圾回收机制不会收回a所占用的资源，因为父函数内部的子函数的执行需要依赖父函数中的变量。
```



#### 闭包形成的原理

✨函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数被全局环境下的变量引用，就形成了闭包

```javascript
//依旧沿用上一个例子来说明：
function a (){
	var i = 0;
	function b(){ 			//函数嵌套函数
		console.log(i);	//内层函数引用了外层函数作用域下的变量
	}
	return b;
}

var c = a() //内层函数被全局环境下的变量引用
c()
```



#### 共享同一个闭包对象

```javascript
举个🌰：
var a
function b() {
  var c = new String('1')
  var d = new String('2')
  function e() {
    console.log(c)
  }
  function f() {
    console.log(d)
  }
  return f
}
a = b()

🐿 提个问题：代码中f引用了变量d，同时f被外部变量a引用，所以形成闭包，导致变量d滞留在内存中，那变量 c呢？是被销毁还是被滞留在内存中？

🌺：解答:c也会滞留在内存中。如上代码形成的闭包包含两个成员，c和d。这种现象成为函数内闭包共享
```

![image-20210326112652206](/Users/other/Library/Application Support/typora-user-images/image-20210326112652206.png)

提个问题：为何变量 c滞留在缓存中，而函数 e 会被回收♻️了呢？

提个问题：
那是不是如果子函数的执行不依赖于父函数的变量他就不形成闭包了呢，即使内部函数被全局的变量引用着？

```
解答：
```



#### 闭包的好处坏处

```javascript
🌺 优点：闭包可以保护函数内的变量安全，函数内部中的变量只有函数内部可以访问到，无法通过其他途径访问，因此保护了变量的安全性不容易造成变量的全局污染。

🌺 缺点：容易造成内存泄漏
function outer(){
	var a = "aaa"
	var inner = function(){
		console.log(a)
	}
	return inner
}
var inner = outer()
inner()
当程序执行完var inner = outer()，其实outer的执行环境并没有被销毁，因为他里面的变量a仍然被被inner的函数作用域链所引用，当程序执行完inner(), 这时候，inner和outer的执行环境才会被销毁调；《JavaScript高级编程》书中建议：由于闭包会携带包含它的函数的作用域，因为会比其他函数占用更多内容，过度使用闭包，会导致内存占用过多
提问环节：
var object = {
     name: "object",
     getName: function() {
        return function() {
             console.info(this,'1111')
        }
    }
}
object.getName()()    // underfined
为什么这里打印的this会指向window?????
```

闭包原理总结：
（子函数）闭包之所以能访问其父函数作用域中的变量，是因为（子函数）闭包的作用域链中存在父函数函数的变量对象，即使父函数执行结束，但由于其变量对象依旧被子函数的作用域引用着，因此不会被内存回收，知道闭包执行借宿后，父函数的变量对象才会被回收

垃圾回收机制♻️
在js中，如果一个对象不再被引用，那么这个对象就会被回收，如果两个对象互相引用，而不再被第三者所引用，那么这两个互相引用的对象也会被回收。（就像上面写的函数，虽然b函数跟a函数牵连着，并且b函数还被a函数return出来了，但如果a函数不被调用或被赋值的话，那么a,b函数都会被回收的。）

#### js垃圾回收策略

```
js 最常用的垃圾回收策略是 ”标记清理“
大意为：
遍历空间下所有的对象，并标记活着的，有被引用的并且最终可以到达根（window/global）的对象。
在垃圾回收阶段的时候，将没有标记进行清除。
```

