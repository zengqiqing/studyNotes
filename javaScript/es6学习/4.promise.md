## **promise**

```javascript
promise语法：
以下为pomise的resolve（成功）
runAsync=()=> {
	var p = new Promise(function (resolve, reject) {
	//做一些异步操作
    setTimeout(function () {
      console.log('执行完成');
      resolve('随便什么数据');
    }, 2000);
    });
  return p;
  }
  componentDidMount(){
    runAsync().then(res => {
    	console.log(res, '回调回来的数据')
    })
}

```

<img src="/var/folders/65/71xg97ds6hnc7_6xq9b987rh0000gp/T/com.yinxiang.Mac/WebKitDnD.RdlcmR/3971A685-DE1E-45C4-A18E-E0CCB5E19E5F.png" alt="3971A685-DE1E-45C4-A18E-E0CCB5E19E5F" style="zoom:75%;" />

**解决回调地狱的方法：链式操作**

回调函数容易造成回调地狱，就是多层回调的问题。promise可以解决这个问题：

​	<img src="/var/folders/65/71xg97ds6hnc7_6xq9b987rh0000gp/T/com.yinxiang.Mac/WebKitDnD.RzBhgU/5C56A84C-2038-4EB3-85C6-281F7AD93091.png" alt="5C56A84C-2038-4EB3-85C6-281F7AD93091" style="z:50%;" />



```javascript
runAsync1() {
var p = new Promise(function (resolve, reject) {
  //做一些异步操作
  setTimeout(function () {
  		resolve('11111数据----');
  	}, 1000);
  });
  return p;
}
runAsync2() {
	var p = new Promise(function (resolve, reject) {
	//做一些异步操作
  setTimeout(function () {
   	 resolve('22222数据-----');
    }, 2000);
    });
  return p;
  }
runAsync3() {
  var p = new Promise(function (resolve, reject) {
    //做一些异步操作
    setTimeout(function () {
    	resolve('3333数据---');
    }, 2000);
  });
return p;
}
componentDidMount() {
  runAsync1()
  .then(function (data) {
    console.log(data, '111111');
    return runAsync2();
  })
  .then(function (data) {
    console.log(data, '22222222');
    return runAsync3();
  })
    .then(function (data) {
    console.log(data, '333333');
  })
}

```

**以下为promise的reject（失败）**

reject的作用是返回错误信息，捕获错误信息要在catch里面捕捉

语法：

![36B7A424-58C7-4306-B403-5024E72FD89E](/var/folders/65/71xg97ds6hnc7_6xq9b987rh0000gp/T/com.yinxiang.Mac/WebKitDnD.RiKUDw/36B7A424-58C7-4306-B403-5024E72FD89E.png)

```javascript
promiseClick() {
	let p = new Promise(function (resolve, reject) {
  setTimeout(function () {
  	var num = Math.ceil(Math.random() * 20); //生成1-10的随机数
    if (num <= 10) {
    	resolve(num);
    }
    else {
    	reject('数字太于10了即将执行失败回调');
    }
  	}, 2000);
  })
  	return p
  }
componentDidMount(){
  promiseClick().then(res => {
  	console.log(res, '--回调--')
  }).catch(error => {
  	console.log(error, '--失败的回调--')
  })
}

```

**注意promise捕捉错误的写法：**

![7037130E-92FF-4796-B54C-E41623ECD131](/var/folders/65/71xg97ds6hnc7_6xq9b987rh0000gp/T/com.yinxiang.Mac/WebKitDnD.ZcW2vd/7037130E-92FF-4796-B54C-E41623ECD131.png)

**promise并发请求：**

**all的用法：**

Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。异步请求的数据是等所有的数据都请求完后一次性返回来

语法：

![D0CD1F4F-DB37-47DE-A3B3-21E52DF91373](/var/folders/65/71xg97ds6hnc7_6xq9b987rh0000gp/T/com.yinxiang.Mac/WebKitDnD.WQfBSc/D0CD1F4F-DB37-47DE-A3B3-21E52DF91373.png)

- Promise.all([事件1，事件2，事件3]).then(res=>{ //回调回来的数据 })

注：promise.all请求回来的数据在数组里的排序和请求所需的时间无关👆，与请求数组事件的排列顺序有关系。👇

![041E9473-E28B-4BC7-AEBC-CE3491F7174B](/var/folders/65/71xg97ds6hnc7_6xq9b987rh0000gp/T/com.yinxiang.Mac/WebKitDnD.QnRwSj/041E9473-E28B-4BC7-AEBC-CE3491F7174B.png)

如果其中一个函数报错，那么没有返回信息，记得用catch捕捉一下错误信息

![62EAA054-D170-43B3-B9F9-AAE6CE437596](/var/folders/65/71xg97ds6hnc7_6xq9b987rh0000gp/T/com.yinxiang.Mac/WebKitDnD.K2kli2/62EAA054-D170-43B3-B9F9-AAE6CE437596.png)

- race的用法：

all是等所有的异步操作都执行完了再执行then方法，那么race方法就是相反的，谁先执行完成就先执行回调。all是回调一个固定的数组，race是谁先回调回来，就回调谁的数据类型和内容

![D72F8963-0B30-4D20-9DA1-EFC1B9E9CAEB](/var/folders/65/71xg97ds6hnc7_6xq9b987rh0000gp/T/com.yinxiang.Mac/WebKitDnD.jhq2g9/D72F8963-0B30-4D20-9DA1-EFC1B9E9CAEB.png)