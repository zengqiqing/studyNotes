#### 基础类型

- 布尔值：

  ```typescript
  let disable:boolean = false;
  ```

- 数字

  ```typescript
  //写法一
  let total:number = 200
  
  //写法二
  let total:number
  total = 300
  total = '2' //这样会报错的！
  ```

  

- 字符串

  ```typescript
  //写法一
  let name:string = 'coco'
  
  //写法二
  let name:string
  name = 'kevin'
  total = 300 //这样会报错的！
  ```

  

- 数组

  ```typescript
  //写法一:不限定数组内值的数量，但限定数组内值的类型
  let list:number[] //(或者这样写：let list:number[] = [1,2,3])
  list = [1,2,3]
  list = [1,'2',3]
  list = []
  
  //写法二：数组泛型，不限定数组内值的数量，但限定数组内值的类型
  let list:Array<number> = [1,2,3,4]
  
  //问题：如果根据数组的索引去访问是否会报错？
  //答：不会，但若访问的个数大于数组长度的索引，那么得出结果为undefined，如果想避免这种不报错但又取不到正确的值，建议使用元祖
  ```

  

- 元祖：允许表示一个已知数量和类型的数组，各元素的类型不必相同

  ```typescript
  let x: [string,number,number,boolean,number[]]
  x = ['1',2,3,true,[1,2,3]]
  ```

  - 当访问一个已知索引的元素，会得到正确的类型，否则会报错

    ```typescript
    let x: [string,number,number,boolean,number[]]
    x = ['1',2,3,true,[1,2,3]] 
    
    console.log(x[2]) //ok
    console.log(x[8]) //Error, 'number' does not have 'substr'
    ```

    

  - 当访问一个越界的元素时，会使用联合类型替代。

    ```typescript
    let x: [string,number,number,boolean,number[]]
    x = ['1',2,3,true,[1,2,3]] 
    x[2] = 'coco'
    
    console.log(x[2]) //Error, 索引为2类型是number，不是(string)类型
    ```

    

- 枚举（enum）

  - 特点：默认情况下从0开始为元素编号
  - 额外操作：可以手动地指定成员的数值
  - 作用：可以由枚举的值得到他的名字

  ```typescript
  //场景一：默认情况下从0开始为元素编号
  enum Color {Red,Green,Blue}
  let c:Color = Color.Red
  console.log(c,'--- k ---') //0
  
  //场景二：可以手动地指定成员的数值
  enum Color {Red=7,Green,Blue}
  console.log(Color.Green) //8
  
  //场景三：可以由枚举的值得到他的名字
  enum Color{Red = 1,Green,Blue}
  let colorName : string = Color[2]
  console.log(colorName) //Green
  
  ```

  - 数字枚举：

    ```typescript
    enum NumberEnum {
        Fisrt = 0,
        Second = 1,
    }
    ```

    

  - 常量枚举：

    ```typescript
    /**
    *	1.只能使用常量枚举表达式
    *	2.在编译阶段会被删除
    * 3.常量枚举的表达式，会在编译的时候计算出结果，然后以常量的显示展示
    * 4.非常量的表达式，不会在编译阶段去计算，而是保留在程序的执行阶段。一定要赋予初始值，否则编译报错
    **/
    //场景一：
    enum Char {
        //常量枚举const
        a,
        b = Char.a,
        c = 1 + 3,
        //计算枚举computed
        d = Math.random(),
        e = '123'.length
    }
    console.log(c.c) //4
    
    //场景二：当我们不需要一个对象，而需要一个对象的值时就可以使用，可以减少编译环境代码。
    const enum Month {
      Jan,
      Feb,
      Mar
    }
    let month2 = [Month.Jan,Month.Feb,Month.Mar]
    console.log(month2) // [0, 1, 1]
    ```

    

  - 字符串枚举：

    ```typescript
    enum StringEnum {
        Up = "UP",
        Down = "DOWN",
        Left = "LEFT",
        Right = "RIGHT",
    }
    
    let c :string= StringEnum.Down
    console.log(c) //DOWN
    ```

    

  - 外部枚举 declare：

    - 特征：用declare关键字定义
    - 外部枚举和非外部枚举的区别：在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的

    ```typescript
    declare enum Enum {
        A = 1,
        B,
        C = 2
    }
    ```

    

- object

  - object表示非原始类型，也就是除了`number`，`string`，`boolean`，`symbol`，`null`或`undefined`之外的类型。

  - 使用`object`类型，就可以更好的表示像`Object.create`这样的API

    ```typescript
    declare function create(o: object | null): void;
    
    create({ prop: 0 }); // OK
    create(null); // OK
    
    create(42); // Error
    create("string"); // Error
    create(false); // Error
    create(undefined); // Error
    ```

    

- any 

  - 在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容时就可以使用any，但尽量不要使用any，会让你养成坏习惯的。

-  void

  ​	 表示没有任何类型，当一个函数没有返回值时，通常见到的返回值类型就是void

  ```typescript
  //使用场景
  function warnUser(x:number,y:number):void{
  	let c = x + y
  	console.log(c)
  }
  warnUser(10,3)
  ```

  

- Null 和 undefined

  - null和undefined是所有类型的子类型，也就是说你可以将null和undefined复制给number类型的变量。

  -  若`strictNullChecks`配置为`true`可以为变量声明undefined和null,但变量被声明为undefined之后不能被赋值为其他类型，只能被赋值为本身
  - 其他变量可以被设为null，但要到tsconfig中把strictNullChecks设为false,若不想设置strictNullChecks，那么要到num处设置联合类型：let num:number|undefined = 123;

- never:表示永不存在的值的类型，例如函数返回异常(比较少用)

  ```typescript
  //场景一
  let error = ()=>{
      throw new Error("error");
  }
  
  //场景二：死循环函数，返回never类型(比较少用)
  let endless = ()=>{
      while(true){}
  }
  ```

  

2.类型断言

- 使用场景：当你比ts更了解某个值时，可以用类型断言实现具有比它现有类型更确切的类型

- 影响：不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用

  ```typescript
  // 场景一
  let someValue:any = "hello"
  let strLength :number = (<string>someValue).length //5
  
  //场景二
  let someValue1:any = 123
  let p1:number = (someValue as number).length //1
  
  let someValue2:any = 'hello'
  let p1:string = (someValue as string).length //5
  ```

  