### 类型推断

### 类型的兼容性

- ts的结构化类型系统的基本原则是：如果x兼容y，那么y至少具有与x相同的属性。举个🌰

  ```typescript
  //场景一：普通用法
  interface Named {
  	name:string
  }
  let y = {name:'coco',age:22}
  let x = Named;
  x = y
  console.log(x) // ok ,因为y里面含有name属性，且为string类型,如果和接口定义的name属性类型不相同，那么x是不等于y的
  
  //场景二： 检查函数参数是使用相同的规则
  
  interface Named{
      name:string
  }
  function greet(params:Named){
      console.log(params.name,'-----')
  }
  let y = {name:'coco',age:22}
  greet(y) // coco
  ```

  

- 比较两个函数是否兼容

  - 根据两个函数的参数类型的包含关系可以判断出两个函数是否兼容

  ```typescript
  //场景一
  let x = (a:number) :number=> {return a};
  let y = (b:number,c:string):number=>{return b}
  
  y = x //ok，因为y函数中包含有x函数所需的参数类型
  x = y //error，因为x函数中没有y参数所需要参数类型
  
  /*
  得出结果：只要两个函数的类型关系是集合关系，
  上面的🌰中，y函数中的参数类型包含了x函数参数类型所需的类型，
  那么x赋值给y是正确的，但y赋值给x是错误的！
  */
  
  /*同样，返回值类型也跟上面的例子一样，类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型*/
  ```

  

- 可选参数及剩余参数

  - 特性：可选参数与必须参数是可互换的。源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误
  - 当一个函数有剩余参数时，它被当做无限个可选参数

- 

- 泛型的比较

  ```typescript
  //场景一
  interface Empty<T> {
  }
  let x: Empty<number>;
  let y: Empty<string>;
  
  x = y; //ok ,这里可以赋值的原因是对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any来比较，然后用结果类型进行比较，就像👆的例子一样
  
  //场景二
  interface NotEmpty<T> {
      data: T;
  }
  let x: NotEmpty<number>;
  let y: NotEmpty<string>;
  
  x = y;  // error ,在这里，泛型类型在使用时就好比不是一个泛型类型
  ```

  

- 