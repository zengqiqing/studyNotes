

```
第一题：材料：来自于官方文档
hook 就是javascript 函数，但使用它们会有两个额外的规则：
1.只能在函数最外层调用 Hook,不要在循环，条件判断或者子函数中调用。
2.只能在 react 的函数组件中调用 hook，不要在其他 js 函数中调用。自定义 hook 除外
```

第一题：为何不能循环,if/else条件或者嵌套函数里面调用 hook?

```
因为如果在 条件语句里面执行hook，会打乱了 hook 的调用顺序，只有在我们组件的最顶层调用 hook才能保证多次渲染之间能保持hook 状态的正确。
```

第二题：useEffect的依赖会跟其摆放的顺序有关系吗？

```
useEffect的依赖跟其摆放顺序没有关系，useEffect 里面的程序只跟依赖内容有关系，跟顺序无关，因为只要其中一个依赖发生变化， 那么useEffect 里面的程序都会执行。
tips:不要在有依赖的 useEffect里面进行 set依赖的 setter,打个比方依赖是 val1,不要在有 val1 的依赖里面进行 setVal1，会死循环的。
```

第三题：高阶组件是什么，他跟 render prop 有什么区别？

```
hoc-高阶组件：j简单理解就是组件工厂，组件的参数为组件，返回值为新组件的函数。组件是将 props 转黄成 UI,而高阶组件是将组件转换成另一个组件。（HOC是纯函数，支持传入多个参数，增强了其适用范围）
我的理解是高阶组件就是组件套组件，组成新组建使用。而普通的组件就只是单纯封装成一个组件来使用。

hoc 的属性代理：
1.操作 props
2.通过 refs 访问组件实例
3.提取 state
4.用其他元素包裹WrappedComponent，实现布局等目的

缺点：
1.当多个 HOC 同时使用时，无法直接判断子组件的 props是哪个 HOC 负责传递的。
2.当存在多个 HOC同时使用时，出现了相同名称的 props，则存在覆盖问题，而且 react 并不会报错，容易找不出问题所在哦~
3.HOC 容易产生许多无用的组件，加深了组件的层级

Render props:
可以将特定行为或功能封装成一个组件，提供给其他组件使用。他将组件可以动态渲染的地方暴露给外部，你不需再关注组件的内部实现，仅需将需要的参数传入即可

hoc 和Render props弊端是本质上都是将复用逻辑提升到父组件中，很容易产生很多包装组件，带来的「嵌套地域」。由于所有抽象逻辑都被其他 React 组件所隐藏，应用变成了一棵没有可读性的组件树。而那些可见的组件也很难在浏览器的 DOM 中进行跟踪。

常见面试题：
1.如何在高阶组件里访问组件实例？
答：可以通过 refs 访问组件实例

2.hoc 和 render prop 和 hook 的区别是什么？

hoc 和 render prop是我们对逻辑代码进行一个抽象化，最终生成一个复用组件的函数，而 hook 里的方法是react提供的 API,hoc和render prop毕竟是一个组件抽象化的过程，并且会出现掺杂各组件的生命周期对逻辑的执行处理，容易让人无法一下读懂代码的含义，而 hook 对比他们会更纯粹，因为 hook 遵循的是函数式变成，useEffect 可以替代大部分常用的声明周期的使用，代码更清晰，组件间的调用更明了，耦合性更低
```

