**this.setState**的是异步的吗？

setState是异步的，他不会⽴即改变state的值，这是为了保持内部的⼀致性，将多个setState产⽣的修改放在⼀个队列⾥，延缓到最后时合并更改渲染，节省render触发频率，这样性能更⾼效。

**React**的原理

react 是⼀个视图层框架，他的数据模式是单向数据流的，只能通过修改props或者setState来进⾏数据的变更。当数据发⽣改变的时候，会产⽣新旧dom，新旧dom会在react的虚拟dom上进⾏diff算法⽐较，得出差异值后，会

把差异部分更新到新的dom上，最后会重新构建新的dom树从⽽驱动视图层的改变。

**redux**的原理：

redux遵循三⼤原则：

单⼀数据源 （⽬的是为了便于维护和调试）

state是只读的，唯⼀驱动state发⽣改变的是action

使⽤纯函数reducer来执⾏修改，因为纯函数没有副作⽤，当状态发⽣改变时，需要返回⼀个新的state，

redux是对新旧state进⾏浅⽐较，是⽐较对象的内存地址的，如果直接修改state那么⽐较的是同⼀个内存地

址，那么redux则不会进⾏响应。

**Diff**算法原理：

diff算法主要的作⽤是⽤来计算新旧dom的差异，是react中开销最⼤的。但diff遵循三⼤策略：

Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。（同层级⽐较，当发现节点不存在时，则会

删除该节点以及旗下的⼦节点，不进⾏下⼀步的⽐较，减少复杂度）

拥有相同类的两个组件将会⽣成相似的树形结构，拥有不同类的两个组件将会⽣成不同的树形结构

对于同⼀层级的⼀组⼦节点，它们可以通过唯⼀ id 进⾏区分。

**useMemo**和**memo**的区别是是什么，**useMemo**和**useCallback**的区别

是什么？

react.memo提供给函数组件使⽤的，class组件使⽤是pureComponent 。react.memo可以解决重复渲染的

问题，优化react的render渲染次数的问题。

useMemo对⽐react.memo性能优化的粒度更细，可以定义依赖，实现细节的pure功能,例如定义依赖决定函

数体内的⼀些逻辑计算或者是⼀些参数作为依赖，决定视图的局部改变。

useCallback的理念跟useMemo⼀样，useMemo和useCallback都会在组件第⼀次渲染的时候执⾏，之后会

在其依赖的变量发⽣改变时再次执⾏；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，

useCallback返回缓存的函数请描述⼀下**useEffect**闭包陷阱

useEffect的闭包陷阱其实就是讲依赖的问题，看下图，当useEffect⾥⾯没有加依赖，我们再销毁⻚⾯的时候打印

a，即使我们执⾏了点击函数，a被增加了，但在useEffect的return⾥⾯打印a的值会是0。这就是闭包陷阱的场

景。

import React,{useEffect,useState} from 'react'

const [a,setA] = useState(0)

useEffect(()=>{

return{

console.log(a)//0

}

})

return( 

<div onClick={()=>{

setA(a+1)//1，2，3，4

}}>{a}</div>

)

**useCallback**的使⽤场景：

useEffect⾥⾯依赖了⼀个函数，⽽这个函数内执⾏了useState,因为每次的useState都会引起变量的赋值，在hook

中，函数也是⼀个变量，那么当useEffect⾥⾯也依赖了这个函数时就会造成⼀个死循环的问题，所以需要⽤

useCallback去包裹函数，减少重复赋值的过程

import React,{useCallback,useEffect,useState} from 'react'

const [a,setA] = useState(null)

useEffect(()=>{

HandleEvent()

},[HandleEvent])

const HandleEvent = useCallback(()=>{

setA({id:1})

},[])

为什么不能条件语句中使⽤**hooks**

因为hook是靠调⽤顺序去保证哪个state对应哪个useState的，只要调⽤调⽤顺序多次渲染之间保持⼀致，react就

能正确地将内部state和对应的hook进⾏关联。若在条件中放置hooks就会出现打乱顺序的情况。什么是闭包？

闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的⼦函数才能读取局部变量，所

以闭包可以理解成“定义在⼀个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

**ReactNative**与**h5**的交互是如何实现的？

RN提供webView api，在⽹⻚加载前通过往webview的injectedJavascript中注⼊⼀段js字符串，在h5⻚⾯加载后

⽴即执⾏，相当于webview端主动调⽤了h5。通过webview绑定的⽅式使RN端向h5发送消息，⽽h5可以通过

postMessage⽅式向RN发送消息。

**Reactnative** 与**React**的区别

1.react是驱动html dom的渲染；React Native是驱动安卓ios原⽣组件的渲染。

2.react适合web端app，rn适⽤于⼿机端app，使⽤rn开发app的性能体验会更好，并且rn有原⽣⽅法的⽀持，更

加容易适配⼿机的元件。

盒⼦居中的⽅法有哪些？

1.（有设定⽗盒⼦）使⽤margin 50% 配合transform -50达到居中⽬的

2.（有设定⽗盒⼦）使⽤定位,设定top,left50%，然后使⽤margin减去⼦盒⼦⾃身⼀半的宽⾼

3.⽗盒⼦设定 display:flex; justify-content: center; align-items: center;

4.⼦盒⼦设为⾏内元素块元素，⽗盒⼦设定line-height和text-align居中

优化：

1.js⽂件体积过⼤，可以缩⼩js,⽂件引⼊可以使⽤lazy-router引⼊，减少⼀次性全部加载的情况，加速⻚⾯。

2.使⽤ngix压缩⽂件功能（gzip）减少静态资源体积。

3.图⽚资源可以放到七⽜云上管理，避免因为图⽚过⼤⽽导致加载过慢的情况

4.代码可以减少重复渲染，避免不必要的render，可以通过react-devtool看渲染情况，使⽤useMemo，memo减

少组件的重复渲染。

5.⻚⾯列表使⽤懒加载，减少⽂件体积

**ES6**新特性

1.es6的let，const 不允许在相同作⽤域下重复声明同⼀个变量块级作⽤域,如果区块中存在let,const命令，那么从

⼀开始就形成了封闭作⽤域形成暂时性死区，已经定义的变量不能重复定义。解决了es5中var存在作⽤域提升问

题。

2.解构赋值，拆解对象，字符串等,使⽤解构进⾏浅克隆组成新对象等值,代替了concat，push等⽅法

 let obj = {id:1,name:'coco',age:22}

const obj1 ={...obj,hooby:'swimming'}

2.箭头函数：⽐以往的函数式表达式更加简洁了。2.1：普通函数和箭头函数的this都是指向谁呢？

普通函数的this指向他的直接调⽤者，若没有找到直接调⽤者则指向window（例如obj.func,那么func中的this指向

就指向obj）

箭头函数没有⾃⼰的this，他的this是继承得来的，所以总是默认指向他当前宿主对象，⽽不是执⾏时的对象。

3.默认参数值：函数默认参数允许在没有值或者undefined被传⼊时使⽤默认形参。

4.promise：Promise 是解决异步编程的⼀种解决⽅案.他的出现是为了解决传统回调函数带来的回调地狱问题.

promise拥有.then 和.catch链式调⽤⽅法,then能接收 promise(onFulfilled) 成功的回调,catch接收失败的回

调（onrejected）.若⼀个 promise ⾥⾯都有写.then 和.catch的捕捉,那么只要 promise 返回状态,那么这个

promise 的状态就属于执⾏完毕,返回fulfilled.若没有写.catch 那么返回rejected告知开发者promise 出错但

未进⾏捕抓.

如果promise的状态是pending，需要将onFulfilled和onRejected函数存放起来，等待状态确定后，再依次将

对应的函数执⾏(发布订阅).

如果 then 返回的是⼀个promise,那么需要等这个promise，那么会等这个promise执⾏完，promise如果成

功， 就⾛下⼀个then的成功，如果失败，就⾛下⼀个then的失败

1.往对象添加对象:通过浅克隆往对象中添加新属性。 let obj = {id: }; let obj1 = {...obj,name:'coco'}`

2.可以结合rest运算符来删除对象属性。 let obj = {id:1,name"coco",age:22,hobby:'swimming'}

**css3**新特性：

Transition：旋转，缩放，移动等常⻅的⽤法（transform:rotate(-45deg)//旋转45度⻆//

transform:translate(1px,2px)设置偏移量）

Animation:css3动画，结合keyFrame使⽤

fiex box(弹性盒模型)

什么是**Typescript**？

Typescript是强类型的Javascript超集，⽀持ES6语法，⽀持⾯向对象编程的概念，如类、接⼝、继承、泛型等。

Typescript并不直接在浏览器上运⾏，需要编译器编译成纯Javascript来运⾏。

说说**Typescript**的优缺点

优点：

1：快速简单，易于学习。

2：编译时提供错误检查， 在代码运⾏前就会进⾏错误提示。

3：⽀持所有的JS库。

4：⽀持ES6，提供了ES6所有优点和更⾼的⽣产⼒。

5：使⽤继承提供可重⽤性。

6：有助于代码结构。

7：通过定义模块来定义命名空间。缺点：

1：需要⻓时间的来编译代码。

2：在使⽤第三⽅库时，需要有三⽅库的定义⽂件，并不是所有三⽅库都提供了定义⽂件，提供的定义⽂件是否准

确也值得商榷。

**Typescript**有哪些基础类型？

number，string，boolean，Symbol，Array，Tuple(元组)，enum(枚举)，object，any，null， undefined，

never（表示那些永不存在的值类型。如总是抛出异常或者根本不会有返回值的函数的返回值类型。）

void （与any相反表示没有任何类型。函数没有返回值时⽤void。）

虚拟列表的实现：

虚拟列表是⼀种根据滚动容器元素的可视区域来渲染⻓列表数据中的某⼀部分的技术。计算偏移量，得出当前渲染

区域可以容纳多少条数据，每次渲染的也就渲染当前可以区域视图的dom节点。打个⽐⽅，刚进⼊⻚⾯时渲染的是

0-10条数据，当我触底加载第⼆⻚时，前⾯0-10条数据往上偏移，当前渲染的是10-20的数据，那么前⾯0-10条的

数据的dom节点不进⾏删除的话，当我有100条数据量的时候就有100个dom节点加载就会很慢，所以虚拟列表就

解决了这个问题