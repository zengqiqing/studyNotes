#### 3.1 语法

- 注释风格

  ECMAScript使用C风格的注释，包括单行注释和块级注释

  ```javascript
  单行注释
  // 我是单行注释
  
  多行注释
  /*
  * 我是多行注释
  */
  
  ```

#### 4.1基本类型和引用类型的值

- 引用类型的值是保存在内存中的对象。与其他语言不同的是，js不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。

##### 4.2 执行环境及作用域

- 执行环境定义了变量或函数，有权访问的其他数据，决定了他们各自的行为

- 全局执行环境被认为是window对象，所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个函数的执行环境中所有代码执行完毕后，该环境就会被销毁，保存在其中的所有变量和函数定义也随之销毁，除了闭包现象

  

- 每个函数都有自己的执行环境，当某函数执行时，函数的环境就会被推入环境栈中，而在函数执行之后，栈将其环境弹出，将控制权交回给 window下的大环境

![image-20210327175019678](/Users/other/Library/Application Support/typora-user-images/image-20210327175019678.png)

- 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境 （ 记住：作用域链保证变量与函数的有序访问，环境下的变量搜索只能沿着作用域链往上搜索，不能往下查找 ）

- 查询标识符：
  搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。（这个其实也是原型链的查找过程）

  

##### 4.3 垃圾回收机制

- js 中最常用的垃圾回收方式是标记清除法，当变量进入环境时，就将变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。
  - 如何标记？
  - 从根集合出发，将所有活动对象及其子对象打上标记。清除阶段则是遍历堆，将非活动对象（未打上标记）的连接到空闲链表上
  - ![image-20210328142228734](/Users/other/Library/Application Support/typora-user-images/image-20210328142228734.png)

##### 6.2 创建对象

- 只要创建一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下， 所有的原型对象都会自动获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在的函数的指针

##### 7.1递归

- 递归的概念：递归函数是在一个函数通过名字调用自身的情况下构成的

##### 7.2 闭包

- 闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数

- 脚本中的函数的调用过程

  ```
  function compare(val1,val2){
  	....
  }
  
  var result = compare(3,2)
  ```

  

1.创建compare()函数：compare函数创建时，会预先包含全局变量对象的作用域链，这个这用于链保存在内部的[[Scope]]属性中。

2.compare函数调用时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。
3.此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端（活动对象指的是compare函数）

#### 7.4私有变量

- 任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数

```
解读：其实从这句话了里面就可以悟到闭包的概念了，js中一切的函数其实都可以算是一个闭包，因为放在闭包里面的变量外部不能访问，但函数能访问外部的函数
```

#### 13 事件流

- 事件冒泡

  ie的事件流叫做事件冒泡（event bubbling），即时间开始时由最具体的元素（文档中嵌套层次最深的那个节点，就是指具体到某一个被嵌套的标签）接收，然后逐级向上传播到较为不具体的节点（文档）

  举个🌰

```javascript
<! DOCTYPE html>
<html>
  <head>
		<title>Event Bubbling Example</title>
  </head>
	<body>
      <div id="myDiv">点我</div>
  </body>
</html>
```

<img src="/Users/other/Library/Application Support/typora-user-images/image-20210329191344787.png" alt="image-20210329191344787" style="zoom:33%;" />

- 事件捕获

  事件捕获的思想是不太具体的节点应该更早接受到事件，而具体的节点应该最后接受事件，事件捕获的用意在于事件到达预定目标前捕获它。

  Ie9，safari，Opera和Firefox目前也都支持这种事件流模型。

  <img src="/Users/other/Library/Application Support/typora-user-images/image-20210329191525707.png" alt="image-20210329191525707" style="zoom:50%;" />

- DOM事件流

  事件流描述的是从页面接受事件的顺序，事件流分为：事件冒泡，事件阶段，事件捕获

  事件流的三个阶段
  <img src="/Users/other/Library/Application Support/typora-user-images/image-20210329192613979.png" alt="image-20210329192613979" style="zoom:50%;" />

